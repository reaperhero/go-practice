# 排序算法


[参考地址](https://www.bookstack.cn/read/For-learning-Go-Tutorial/src-chapter16-01.0.md)
[参考地址](https://www.runoob.com/w3cnote/sort-algorithm-summary.html)

![](../标准库/image/849589-20180402133438219-1946132192.png )

- sort包排序

sort，实现了int，float64和string三种基础类型的排序接口
Go中排序的包sort,里面是由三种排序算法(插入排序．快排和堆排序)具体实现的，因此真的排序算法又可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等

- 冒泡排序

冒泡排序(Bubble Sort) 是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，依次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，此时该数列就已经排序完成
优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。


- 选择排序

(Selection sort)它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推。
在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。


- 插入排序

(Insertion Sort) 是一种简单直观的排序算法。工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间
比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。


- 希尔排序

[希尔排序](https://studygolang.com/articles/13855)
(Shell Sort),又称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。相较直接插入排序，希尔排序减少了比较和交换的次数，在中小规模的排序中，性能表现较好。但随着数据量增大，希尔排序与其他更好的排序算法（快排、堆排、并归等）仍有较大差距。
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序

- 归并排序

(Merge sort) 是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

- 快速排序

(Quicksort),又称划分交换排序（partition-exchange sort），简称快排。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

算法原理:
```
从数列中挑出一个元素，称为 “基准”(pivot).
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作.
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序
```


- 堆排序

(Heapsort) 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列.
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列

算法原理:
```
创建一个堆 H[0……n-1].
把堆首（最大值）和堆尾互换.
把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置.
重复步骤2，直到堆的尺寸为 1
```

- 桶排序

(Bucket sort),工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
为了使桶排序更加高效，我们需要做到这两点：

1. 在额外空间充足的情况下，尽量增大桶的数量.

2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

算法原理：
```
设置一个定量的数组当作空桶子.
寻访序列，并且把项目一个一个放到对应的桶子去.
对每个不是空的桶子进行排序.
从不是空的桶子里把项目再放回原来的序列中.
```


- 计数排序

(Counting sort) 是一种稳定的线性时间排序算法.计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序使用一个额外的数组C,其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C 来将A中的元素排到正确的位置。

算法原理
```
找出待排序的数组中最大和最小的元素.
统计数组中每个值为i的元素出现的次数，存入数组C的第i项.
对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加).
反向填充目标数组：将每个元素 i放在新数组的第C[i]项，每放一个元素就将C[i]减去1.
```

- 基数排序

(Radix sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

